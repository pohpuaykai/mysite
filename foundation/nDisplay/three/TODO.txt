-draw many many many many many many electrical circuits to test|improve equationfinders, 2D(schematic)|3D display, bipartiteSolver?
--<<Foundations of Analog and Digital Electronic Circuits>> better read and no errors on answers
---do this to improve bipartiteSolver?
--<<Schaum's 3000 Solved Problems In Electric Circuits>>
-make pretty animations :D
--try to achieve the voltage|current divider equation with bipartite_solver  for 
---another stupid idea for scoring bipartiteSolver
----LCSS each equation einander, go for the highest scoring one given the neighbour?
----group equations together by Laplacian, by LCSS_score, and try to apply them together in succession, https://en.wikipedia.org/wiki/Laplacian_matrix
----if current LCSS is similiar enough to existing visited schemeEq, then we can early terminate?
----maybe its time to work on the Damarau-Levenshtein to get it to be compliant with schemeLabels
---we will have to store the schemeEquation in State, and then LCSS with reducingManipulations to give reducibleStates higher score
----instead of LCSS+scoring why not call simplify on each state? that will reduce statespace, but will each step become too long time?
----Also if equations resembles a polynomial, should it have a higher score for bipartite?
----This also goes for combingSearch, if equations resembles a polynomial, should it be an earlier termination for combingSearch?
---What if we stack manipulations but only so that they produce resultingManipulations, that reduce the number of schemeLabels or levels of outputPattern? and then save those stacked_manipulations as 1 manipulation? If so, then our search will have more termination_points?
---An idea from <<Foundations>> is to form simple polynomials from existing equations, where we can then select solvingVariables so that the #solvingVariables=#equations, and the use Cramer'sRuleWithCAS to solve for their closed form
----how to form 'simple polynomials?'
----how to select solvingVariables so that #solvingVariables=#equations
----WORKON symbolicGaussian

---dc_twoResistor_parallel.js
---dc_twoResistor_series.js
---Q2_3_5_aMoreComplexCircuit__P84.js



USE 1 or 2 facebook resistor meshes (EletricalEngineeringXYZ) as examples first, then use your textbookS
-To build this pipeline:
--Manual Draw components in 3D
--Extract Graph (Network) information=Gi
--Generate 2D Symbolic Circuit Diagram (schematics) with SVG (OPTIONAL for now)
--Find symbolic_equations like KVL, KCL, hFE, Ohm_Law, multiple_ICR_addition, with graph_algos and Gi
--Use CAS to solve symbolic_equations, return solving_steps and solved_results to 3D, 
--make pretty animation :D
--scrap electronic store data & feed to optimiser like simplexTableau for which to buy?
---symbolic simplex_tableau, and then zero derivative wrt to each controllable_variable => many modal_optimal_solutions....?














TODO:




###############################################################
2. Component~.js ~=[ACMicroGenerator]
"""TODO
(Overall size): 30mm×30mm×13.2mm (height)
(Formed body): 28.5mm×10mm
(Fixed plate): 30mm×30mm
(Output shaft size): 3mm×31.5mm (length)
(Output line length): about 70mm
https://www.amazon.com/gp/product/B0DHNC3114
"""
8. Component~.js ~=OpAmp (IC Chip)<<<<<<<<<<<<<<<<<<<<<<BottomUpSampler
###############################################################



--scene acceleration (for later: mechanical engineering), ChatGPT recommends: (frontend render speed with user interaction)
--
import { MeshBVH, acceleratedRaycast } from 'three-mesh-bvh';
THREE.Mesh.prototype.raycast = acceleratedRaycast; // override default raycast

// Then build the BVH
geometry.computeBoundsTree = MeshBVH;






https://threejs.org/manual/#en/loading-3d-models
https://threejs.org/docs/#examples/en/loaders/GLTFLoader
https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#concepts



