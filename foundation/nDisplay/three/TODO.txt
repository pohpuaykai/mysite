REFACTORING recommend.py
-remove the recommendtest?
-split up the different types of search into different files?
-so recommend should be a folder?
-refactoring bipartiteSearch?
--temporaryVariables should be passed around, not in a class......
-refactoring combingSearch
--rename?
---foundation\automat\core\manipulate\recommend\tests\solvetest.py
---foundation\ecircuit\equationSolvers\bipartitesolver.py

-cramer's rule|GE, maybe think, how the existing heuristics are related to the cramer's rule|GE?


~THOUGHTS FROM MY PHONE
=Search|combing or not|should have savepoints, incase search takes too long and breaks
=For refactoring heuristics, what are the inOut of heuristics, types of heuristics by inOut? And their position in OG code?
=Have another version of bipartite, where the solving is also done, so that we can find simplifiablestates. Because I am not sure which algorithm will be faster.. or we can mix and match...
=Take history of state, feed to nnmc_give_details_for_different_variety, give which state|s to go
=If we reach a simplifiable state, then we solve the whole path explicitly with simplification and then we modify the whole queue accordingly. Recognise_simplifiable_state,
=If path contains newEqs then we do not add to queue... But we might miss possible equations... Maybe for long search...
=Start node some equation, with the structure you want in the end... If there are 3 variables expected at the end, then use a equation with 3 variables to start{HEU}
=Condensed manipulations in a npy, not as a py file yet... might it speed up search? We can stack manipulations together to make them 1 manipulation to speed up search, larger experience file. A more effective way to stack might be to do so for reducingManipulations
=Equations with more overlaps(while keeping the use original original) with current equation in unwanted variables should be tried first...{HEU} {similar to tree in tree}
=If you applied swapping as the last manipulation, you should not apply it again, even if it's no hin,because in these manipulation vor=hin{HEU}
=Try to favour states that use up original equations first, not those that are added later? Later added equations less points, complicated equations less points{HEU}
=Simple formulas should be given higher priority, so every insert into priorityqueue changes priority. nnmc_give_details_for_different_variety{HEU}
=Combinatorially skipNodes, nnmc_give_details_for_different_variety
=There is some metashape|metastructure|labelDiffCount|metalabelPosition when it is considered simple enough. It would be termination condition. "Polynomial" this can then be fed into symbolicGaussian. nnmc_give_details_for_different_variety
=After all the nnmc, use angluinAlgo to find DFA|CFL for self programming?



~THOUGHTS FROM TODO

-draw many many many many many many electrical circuits to test|improve equationfinders, 2D(schematic)|3D display, bipartiteSolver?
-refactor bipartiteSearch
--each heuristic is its own class, and all the same heuristic in a folder...
-current_divider 
--<<Foundations of Analog and Digital Electronic Circuits>> better read and no errors on answers
---do this to improve bipartiteSolver?
--<<Schaum's 3000 Solved Problems In Electric Circuits>>
---another stupid idea for scoring bipartiteSolver
----LCSS each equation einander, go for the highest scoring one given the neighbour?
----group equations together by Laplacian, by LCSS_score, and try to apply them together in succession, https://en.wikipedia.org/wiki/Laplacian_matrix
----if current LCSS is similiar enough to existing visited schemeEq, then we can early terminate?
---we will have to store the schemeEquation in State, and then LCSS with reducingManipulations to give reducibleStates higher score
----instead of LCSS+scoring why not call simplify on each state? that will reduce statespace, but will each step become too long time?
----Also if equations resembles a polynomial, should it have a higher score for bipartite?
----This also goes for combingSearch, if equations resembles a polynomial, should it be an earlier termination for combingSearch?
---What if we stack manipulations but only so that they produce resultingManipulations, that reduce the number of schemeLabels or levels of outputPattern? and then save those stacked_manipulations as 1 manipulation? If so, then our search will have more termination_points?
---An idea from <<Foundations>> is to form simple polynomials from existing equations, where we can then select solvingVariables so that the #solvingVariables=#equations, and the use Cramer'sRuleWithCAS to solve for their closed form
----how to form 'simple polynomials?'
----how to select solvingVariables so that #solvingVariables=#equations
----WORKON symbolicGaussian
----can we use cramer'sRule as a heuristic to guide which variables to choose?<<<<<<<<<<<<<<<<<<<<<<<<<<
-----unwanted Variables seem to map to dependent&independentVariables of cramer'sRule...








-make pretty animations :D
--tobe done before recording and uploading to YOUTUBE :D
---maybe also mention the type of variable in your audio? is it a resistance_variable, current_variable, voltage_variable in solvingStep
---KCL should preferably only return the wireNode to be highlighted, please do not highlight the whole loop very confusing<<<<< check this i think this is already done
---maybe also mention the type of simplification_step that is being performed? because saying the exact same thing over and over is stupid
---there is also a HeisenBug on frontend, that appears only sometimes: The AudioContext encountered an error from the audio device or the WebAudio renderer.
---the color of the highlighting... can be improved.... how? contrast? average_contrast? shiny_?
--- the equations should hang around for a little longer, else it is confusing for the viewer





USE 1 or 2 facebook resistor meshes (EletricalEngineeringXYZ) as examples first, then use your textbookS
-To build this pipeline:
--Manual Draw components in 3D
--Extract Graph (Network) information=Gi
--Generate 2D Symbolic Circuit Diagram (schematics) with SVG (OPTIONAL for now)
--Find symbolic_equations like KVL, KCL, hFE, Ohm_Law, multiple_ICR_addition, with graph_algos and Gi
--Use CAS to solve symbolic_equations, return solving_steps and solved_results to 3D, 
--make pretty animation :D
--scrap electronic store data & feed to optimiser like simplexTableau for which to buy?
---symbolic simplex_tableau, and then zero derivative wrt to each controllable_variable => many modal_optimal_solutions....?














TODO:



-draw many many many many many many electrical circuits to test|improve equationfinders, 2D(schematic)|3D display, bipartiteSolver?
-refactor bipartiteSearch
--each heuristic is its own class, and all the same heuristic in a folder...
-current_divider 
--<<Foundations of Analog and Digital Electronic Circuits>> better read and no errors on answers
---do this to improve bipartiteSolver?
--<<Schaum's 3000 Solved Problems In Electric Circuits>>
---another stupid idea for scoring bipartiteSolver
----LCSS each equation einander, go for the highest scoring one given the neighbour?
----group equations together by Laplacian, by LCSS_score, and try to apply them together in succession, https://en.wikipedia.org/wiki/Laplacian_matrix
----if current LCSS is similiar enough to existing visited schemeEq, then we can early terminate?
---we will have to store the schemeEquation in State, and then LCSS with reducingManipulations to give reducibleStates higher score
----instead of LCSS+scoring why not call simplify on each state? that will reduce statespace, but will each step become too long time?
----Also if equations resembles a polynomial, should it have a higher score for bipartite?
----This also goes for combingSearch, if equations resembles a polynomial, should it be an earlier termination for combingSearch?
---What if we stack manipulations but only so that they produce resultingManipulations, that reduce the number of schemeLabels or levels of outputPattern? and then save those stacked_manipulations as 1 manipulation? If so, then our search will have more termination_points?
---An idea from <<Foundations>> is to form simple polynomials from existing equations, where we can then select solvingVariables so that the #solvingVariables=#equations, and the use Cramer'sRuleWithCAS to solve for their closed form
----how to form 'simple polynomials?'
----how to select solvingVariables so that #solvingVariables=#equations
----WORKON symbolicGaussian
----can we use cramer'sRule as a heuristic to guide which variables to choose?<<<<<<<<<<<<<<<<<<<<<<<<<<
-----unwanted Variables seem to map to dependent&independentVariables of cramer'sRule...

---dc_twoResistor_parallel.js
---dc_twoResistor_series.js
---Q2_3_5_aMoreComplexCircuit__P84.js








###############################################################
2. Component~.js ~=[ACMicroGenerator]
"""TODO
(Overall size): 30mm×30mm×13.2mm (height)
(Formed body): 28.5mm×10mm
(Fixed plate): 30mm×30mm
(Output shaft size): 3mm×31.5mm (length)
(Output line length): about 70mm
https://www.amazon.com/gp/product/B0DHNC3114
"""
8. Component~.js ~=OpAmp (IC Chip)<<<<<<<<<<<<<<<<<<<<<<BottomUpSampler
###############################################################



--scene acceleration (for later: mechanical engineering), ChatGPT recommends: (frontend render speed with user interaction)
--
import { MeshBVH, acceleratedRaycast } from 'three-mesh-bvh';
THREE.Mesh.prototype.raycast = acceleratedRaycast; // override default raycast

// Then build the BVH
geometry.computeBoundsTree = MeshBVH;






https://threejs.org/manual/#en/loading-3d-models
https://threejs.org/docs/#examples/en/loaders/GLTFLoader
https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#concepts



